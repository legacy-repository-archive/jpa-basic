# JPA 소개    
기존 JDBC를 사용했을때 애플리케이션 **비즈니스 로직보다 SQL 과 JDBC API를 작성하는 데 더 많은 시간을 보냈다.**              
물론, 코드 중복을 없애기 위해서 Ibatis나 JDBCTemplate 같은 SQLMapper 를 도입했지만 여전히 반복해서 작업을 해야 했다.            
    
또한 데이터를 테이블에 맞춰서 보내야했기 때문에            
객체 구조는 테이블 형태에 의존적이게 될 수 밖에 없었고          
설계 또한 **객체 중점이 아닌 테이블 중점으로 설계**가 될 수 밖에 없었다.             
즉, **객체지향 모델링에 대한 장점을 포기하고 데이터 중심 모델로 설계 패러다임이 바뀐 것이다.**       
       
하지만 이러한 문제점을 해결하고자 만들어진것이 있었으니 바로 **ORM 프레임워크** 이다.         
ORM 프레임워크는 객체와 관계형 데이터 베이스 간의 차이를 중간에서 해결해주는 역할을 하고 있다.      
    
JPA는 자바 ORM 기술 표준이다.    
반복적인 코드를 줄이고 개발자는 개발에 조금 더 집중 할 수 있는 환경을 만들어준다.    
참고로 저자님께서 말씀하시는 말 중에 와닿는 말이 있어 남겨본다 **개발자는 SQL 매퍼가 아니다.**     

* **[1. SQL을 직접 다룰 때 발생하는 문제](#SQL을-직접-다룰-때-발생하는-문제)**       
    * **[1-1. 반복 반복 반복](#반복-반복-반복)**
    * **[1-2. SQL에 의존적인 개발](#SQL에-의존적인-개발)**
    * **[1-3. JPA와 문제해결](#JPA와-문제해결)**   
* **[2. 패러다임 불일치](#패러다임-불일치)**       
    * **[2-1. 상속](#상속)**
    * **[2-2. 연관관계](#연관관계)**
    * **[2-3. 객체 그래프 탐색](#객체-그래프-탐색)**
    * **[2-4. 비교](#비교)**
* **[3. JPA를 이용한 패러다임 해결](#JPA를-이용한-패러다임-해결)**       
    * **[3-1. JPA와 상속](#JPA와-상속)**
    * **[3-2. JPA와 연관관계](#JPA와-연관관계)**
    * **[3-3. JPA와 객체 그래프 탐색](#JPA와-객체-그래프-탐색)**
    * **[3-4. JPA와 비교](#JPA와-비교)**

___
## SQL을 직접 다룰 때 발생하는 문제  
### 반복 반복 반복 
일반적인 JDBC를 이용했을 때 DAO의 처리 방법은 아래와 같다.    
     
1. SQL 작성        
2. JDBC API를 사용해서 SQL 실행      
3. 실행 결과를 알맞게 처리 (조회 기능일 경우 객체로 매핑)       

위 3가지 과정은 CRUD 에서 모두 동일한 절차이며 이는 **반복적인 작업**이다.      
이뿐만 아니라 `Connection`하고 이를 `Close` 해주는 작업까지 포함해야한다.       
물론, JDBCTemplate 에서 Connection과 Close 작업에 대한 반복을 해결해주었지만    
우리는 아직도 SQL이 반복적인 코드를 생산할 수 밖에 없다.    

**생각해볼점**
```
member 라는 객체를 DB에 저장하고자 하면     
member 필드들을 꺼내온뒤 SQL에 삽입하는 작업을 진행해야 한다.       
그리고 이러한 작업은 앞서 말한 3가지 절차를 거쳐애한다.        

하지만 대상이 DB가 아닌 Collection 의 List라고 가정을 해보자    
List<Member> list = new ArrayList(); 
list.add(member);
우리는 단순히 리스트에 추가하기만 하면 된다.    
이것이 데이터 중심이 아닌 객체지향 중심의 개발이고 우리는 이와같은 처리를 하도록 원하고 있다.   
```

### SQL에 의존적인 개발   
앞선 과정에서 우리는 SQL 을 이용한 DAO를 완성했다고 가정을 하자       
어느날 갑자기 클라이언트측에서 새로운 기능을 요구해서 테이블에 새로운 필드를 추가시켜야 하는 상황이 발생하였다.   
이럴 경우 기존에 짜여진 관련된 모든 코드를 수정해야 한다.    
       
1. DTO 수정               
2. DAO SQL 쿼리 및 statement 수정        
3. 기타 의존된, 연관된, 관련된 코드들 수정         
    
결론적으로 SQL 문을 바꾸게 됨으로써 객체의 필드를 바꾸고 이에 관한 코드도 변경해주어야 한다.      
만약 이렇게 관련된 코드가 100개, 1000개 있다면 일일이 다 바꿔줘야 하는 수고로움이 발생한다.          
      
정리하자면 객체가 연관된 코드, 객체들을 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려 있다.     
이런 방식의 가장 큰 문제점은 데이터 접근 계층을 사용해서 SQL을 숨겨도      
어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다는 점이다.       
      
그리고 이러한 SQL에 의존적인 엔티티들은 변동이 심하므로 개발자가 신뢰할 수 없으며    
물리적으로 SQL과 JDBC API를 분리했다 하더라도 논리적으로 강한 의존성을 가지고 있다는 것이다.    

애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점을 요약하자면 아래와 같다.
   
* 진정한 의미의 계층 분할이 어렵다.   
* 엔티티를 신뢰할 수 없다.   
* SQL에 의존적인 개발을 피하기 어렵다.   
     
**용어**
```
엔티티 : 비즈니스 요구사항을 모델링한 객체   
```  
   
### JPA와 문제해결 
JPA는 기존에 개발자가 직접 SQL구문을 기술하고 사용하는 것이 아닌        
JPA API를 이용함으로써 **JPA가 개발자 대신에 적절한 SQL을 생성해서 데이터베이스에 전달한다.**          
즉, 개발자는 JPA API만 사용하면 SQL 구문을 기술하지 않아도 된다는 의미이다.    
    
* 저장 기능 
    * `persist(Entity)` : 객체를 데이터베이스에 저장한다. **INSERT SQL**
* 조회 기능 
    * `find(Entity.class, id)` : 객체 하나를 데이터베이스에서 조회한다. **SELECT SQL**  
* 수정 기능 
    * JPA는 별도의 수정 메서드를 제공하지 않는다.    
    * 영속성 컨텍스트를 이용해서 조회한 데이터 엔티티의 값을 수정하면 트랜잭션을 커밋할 때 같이 수정해준다.    
* 연관된 객체 조회  
    * JPA는 객체를 필드로 가질 수 있기때문에 조회된 데이터에서 연관된 특정 객체를 추출할 수 있다.    

___
## 패러다임 불일치 
애플리케이션은 발전하면서 그 내부의 복잡성도 점점 커진다.      
즉, **지속 가능한 애플리케이션을 개발하는 일은 끊임없이 증가하는 복잡성과의 싸움이다.**      
복잡성을 제어하지 못하면 결국 유지보수하기 어려운 애플리케이션이 된다.      
    
객체지향 언어에서는 **상속, 다형성, 추상화, 정보은닉**등을 지원해주며 이를 이용해 복잡성을 제어해준다.     
하지만 **데이터 중심이 되어버린 객체는 이러한 객체지향 언어의 장점을 사용하기 힘들어지고 이로인해 복잡성도 크게 증가한다.**   
객체가 단순하면 상관이 없지만 객체가 상속받았거나 다른 객체를 참조(필드로 사용)하고 있다면 객체의 상태를 저장하기는 쉽지않다.     
    
예를 들면 **회원 객체를 저장해야 하는데 회원 객체가 팀 객체를 참조하고 있다면 팀 객체도 같이 저장해줘야한다.**   
만약 그러지 않을 경우 회원 객체는 팀 객체와의 연관성을 잃어버리는 문제가 발생한다.     
      
그래서 객체 지향 언어의 장점을 유지하고자 직렬화, 역직렬화로 데이터를 저장하는 것을 지원하지만       
이 방법은 직렬화된 객체를 검색하기 어렵다는 문제점이 있으므로 현실성이 없고 사용하기 까다롭다.      

그렇다면 가장 나은 방법은 관계형 데이터베이스에 객체를 저장하는 것인데         
관계형 데이터베이스는 데이터 중심으로 구조화 되어 있고 집학적인 사고를 요구한다.          
즉 **추상화, 상속, 다형성 같은 개념이 없고 이로인해 객체도 데이터 중심으로 설계를 하게 되었다.**           

간략하게 정리하자면       
객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르고 둘의 기능과 표현도 다르므로 이를 **패러다임 불일치라 말한다.**          
   
* 객체 : 다양한 객체의 장점을 이용한 복잡성 해소    
* RDB : 데이터 중심 구조화 및 집합성 강조    
   
애플리케이션은 자바라는 객체지향 언어로 개발하고      
데이터는 관계형 데이터베이스에 저장해야 한다면,       
**결국 패러다임의 불일치 문제를 개발자가 중간에서 해결해야 한다.**       
그리고 이를 해결하는데 너무 많은 시간과 코드를 소비하는데 있다.     

이제 이러한 패러다임 불일치를 개발자가 해결하는 방법과 문제점을 살펴보자   

### 상속   
**객체는 상속이란 개념이 있지만 테이블은 없다.**   
그나마 데이터베이스 모델링에서 이야기하는 **슈퍼타입 서브타입 관계를 사용하면 상속과 가장 유사한 형태**로 테이블을 설계할 수 있다.   
 
```
        ITEM
   ______|______
   |     |     |
ALBUM   MOVIE   BOOK  
```
```java
class Item{}
class Album extends Item{}
class Movie extends Item{}
class book extends Item{}
```
하지만 이렇게 분리한 상태에서 SQL을 수행할 경우 최소 2번은 수행해야 한다.   
   
예를 들어      
`Album`객체의 값을 데이터베이스에 넣어줄때            
`Album`객체는 `Item` 객체를 상속받고 있기에 **Item 관련 데이터도 같이 추가되어야 한다.**              
         
하지만 객체로서는 연관이 있지만 위 같은 데이터베이스 구조에서는 Album과 Item 테이블은 분리되어 있기에         
```sql 
INSERT INTO Item ...
INSERT INTO Album ...
```
이러한 작업을 거쳐야한다.    

이는 조회, 수정, 삭제도 마찬가지이다.      

### 연관관계   
**객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.**     
반면에 테이블은 **외래키**를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.      

**객체**
```java
class Member{
    Team team; // 참조  
    ...
    Team getTeam(){
        return team;
    }
}
```

**테이블**    
|Member|
|------|
|Member PK|
|Team FK|

|Team|
|------|
|Team FK|
   
객체에서는 한번에 처리가 가능한 것을 테이블에서는 2번에 나눠서 처리해야 되는데 방식은 아래와같다.   

```java
User user = findUser();
Team team = user.getTeam();
```
기존 객체를 이용한 방식은 단순하게 객체내의 요소들을 이용하면 쉽다.   

```java
User user = userDao.findUser();
Team team = TeamDao.findTeam(user.getTeamId());
```
하지만 이를 데이터베이스 기준으로 코드를 짠다면 위와같이 DAO를 2개 생성하고   
2번 데이터베이스와 연결하여 작업을 수행해야한다.   
이유는 앞서 말했듯이 테이블이 2개로 구분되어 있기때문이다. (테이블을 2개로 나눈것이 잘못이라는 얘기는 아니다.)     
        
이렇듯 객체와 테이블의 패러다임 불일치성으로 인해 위와 같이 접근을 하게 되고    
불필요한 연산 과정을 사용하게 된다는 문제점이 있다.          
   
그렇다고 객체지향적으로 디자인 하는 것이 완벽하게 좋다는 얘기는 아니다.     
DB에서는 User가 기준이든 Team이 기준이든 JOIN을 이용하여 데이터를 찾을 수 있지만      
객체에서는 User에서 Team을 도출할 수 있지만 Team 에서 User를 도출하기는 힘들다.   
   
**연관관계 - 객체를 테이블에 맞추어 모델링** 
객체를 테이블에 맞추어 모델링(데이터 중심 모델링)하면 아래와 같다.  
   
```java
class Member{
    Long teamId; // 참조  
    ...
}
class Team{
    Long id;
}
```
이렇게 사용할 경우 테이블에서 **저장하거나 조회할 때는 편리하다.**   
왜냐하면 각각의 객체를  각각의 테이블에 대응하여 처리해주면 되기 때문이다.    
     
하지만 사실 Team_ID 외래 키 값을 보관하는 teamId 필드에는 문제가 있다.    
우선 연관된 Team을 찾는 연산이 추가적으로 생기던가     
teamId 의 잘못된 코드로 변겨될 경우 연관된 Team도 같이 변형하거나 불일치성을 띄지 않게 관리해야하는 복잡성이 생긴다.       
이런 방식을 따르게 되면 객체 지향의 장점을 잃어버리게 되는 것이다.   

**연관관계 - 객체를 객체지향에 맞추어 모델링** 
그렇다면 객체를 객체지향에 맞추어 모델링 하는 것은 좋은 것일까?    

```java
class Member{
    Team team; // 참조  
    ...
    getTeam(){
        return team;
    }
}
class Team{
    Long id;
}
```
이처럼 객체지향적으로 모델링을 할 경우 객체간의 연관성에 대한 문제는 없어진다.        
대신 테이블 기준으로 다시 본다면 **저장하거나 조회하기는 쉽지않다.**       
왜냐 하면 하나의 객체를 쪼개서 각각의 테이블에 나누는 로직을 생성해주어야 하기 때문이다.               
(이같은 작업을 데이터베이스에서 하던가 DAO에서 추가로 로직을 짜주어야한다.)      
    
**정리하자면**        
객체모델은 외래 키가 필요 없고 단지 참조만 있으면 된다.         
테이블은 참조가 필요 없고 외래 키만 있으면된다.             
그리고 결국은 이같은 패러다임을 맞추기 위해서 **개발자가 중간에서 변환 역할을 해야한다.**          
    
이러한 변환 역할을 간단히 보여주자면    
    
```java
member.getTeam().getId; 
```
위 같이 객체내의 id 필드를 통해서 ID값을 이용한 테이블 참조를 진행하면 된다.         
    
### 객체 그래프 탐색 
회원이 소속된 팀을 조회할 대는 참조를 사용해서 연관된 팀을 찾으면 되는데,      
이와같은 과정을 **객체 그래프 탐색**이라한다.        
즉, **객체가 참조를 이용해서 연관된 객체를 찾는 것**을 의미한다.         
   
다음은 객체 그래프를 탐색하는 코드이다.    
```java
member.getOrder().getOrderItem()...   
```
      
하지만 다음 SQL을 사용하여 member와 team에 대한 데이터만 불러올 경우  
Order와 같이 다른 객체 그래프는 데이터가 없으므로 null 값을 가지고 이는 탐색을 할 수 없게한다.      
```sql
SELECT M.*, T.*
    FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```
```java
member.getOrder(); // null -> member와 team에서만 했으므로 order_id 값이 있더라도 조인을 안해서 데이터가 없다    
```
즉, **SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.**    
이것은 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데        
언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수는 없기 때문에 개발자에게는 큰 제약이다.       
(SQL 쿼리랑 이것을 사용하는 메서드에 대해서도 숙지하고 관리해야하는 어려움이있다.)       
   
```java
public void process(){

    Member member = memberDAO.find(memberId); // SQL 실행
    member.getTeam(); // 앞선 쿼리로 Team 객체 그래프를 탐색 가능한가? 
    member.getOrder().getDelivery(); // Order 객체 그래프 탐색 가능한가 그리고 가능하도라도 Delivery는?     
}
```
위 코드와 같이 **언제 끊어질지 모르기 때문에 결국에는 DAO를 열어서 SQL을 직접 확인해야 한다.**   
이것은 앞서 말했듯이 SQL에 의존적인 개발로 논리적으로 종속되어서 발생하는 문제이다.    
    
**반대로**    
객체 그래프 탐색을 위해서 모든 데이터를 JOIN하여 가져오는 것은 성능적으로 많은 이슈가 있다.    
결국 상황에 따라서 DAO와 SQL 쿼리문을 만들고 사용해야 하고 이를 숙지 및 관리해야한다.   

### 비교 
데이터베이스는 **기본 키의 값으로 각 ROW를 구분**한다.        
반면에 객체는 **동일성 비교**와 **동등성 비교**라는 2가지 비교방법이 있다.       
     
* 동일성 비교 : `==` 비교, 객체의 주소 값을 비교   
* 동등성 비교 : `equals()` 비교, 객체 내부의 값을 비교    
   
따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.    

```java
String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
..Member를 얻기위한 DB 로직..
return new Member(DB로직을 통해 얻은 값);
```
```java
Member member1 = memberDAO.getMember(100);
Member member2 = memberDAO.getMember(100);

System.out.println(member1 == member2) // 메모리 주소가 다르므로 false 가 출력된다.   
```
데이터베이스 관점으로 보면 둘은 같은 데이터이지만     
자바 코드를 통해서는 둘은 같은 데이터가 아니라고 나온다.      
물론 `equals()`를 사용하여 동등성에 대한 true를 얻을 수 있지만        
동일성에 대해서 false 값을 가져야 된다는 것이 동일한 데이터임에도 그 순리가 맞지않다.          
        
```java
Member member1 = list.get(0);
Member member2 = list.get(0);

System.out.println(member1 == member2) // 메모리 주소가 같으므로 true가 출력된다.   
```
그리고 이러한 데이터를 DB가 아닌 객체지향 관점으로만 본다면 true 값을 가질 것이다.   
       
이러한 패러다임 불일치를 해결하기 위해서      
로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 것은 쉽지않다.     
여기에 여러 트랜잭션이 동시에 실행되는 상황까지 고려하면 문제는 더 어려워진다.      

___ 
## JPA를 이용한 패러다임 해결 
### JPA와 상속    
상속된 객체를 테이블 분리를 이용해 분리하였기에 우리는 2번의 SQL 구문을 사용했다.       
JPA는 이러한 상속과 관련된 패러다임을 해결해주는데 마치 **자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면된다.**      
 
**기존 방식** 
```java
public void save (Item item, Album album){
    String insertSQL1 = "INSERT INTO ITEM...";
    String insertSQL2 = "INSERT INTO ALBUM...";
    ...
    st.executeUpdate(insertSQL1);
    st.executeUpdate(insertSQL2);
    ...
}
```

**JPA 방식**
```java
public void save(Album album)(){
    jpa.persist(album);
}
```

조회도 마찬가지이다.   

**기존 방식**
```java
public Album getOne(Long id){
    String selectSQL = "SELECT I.*, A.* FROM ITEM I JOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID";
    rs = st.executeQuery(selectSQL);
    
    ... // Item 객체와 Album 객체를 처리해주는 로직 
    
    return album;
}
```

**JPA 방식**
```java
public Album getOne(Long id)(){
    return jpa.find(Album.class, id);
}
```
이렇듯 단순 album 객체를 이용하여 상속에 대한 불필요한 연산을 줄일 수 있고 이는 객체지향의 장점을 이용한 것이다.      

### JPA와 연관관계   
JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다.   

```java
member.setTeam(team);
jpa.persist(member);
```
개발자는 기존 객체지향 모델을 그대로 사용하면서 JPA API를 사용해주기만 하면된다.    
**JPA는 참조를 외래키로 변환해서 적절한 INSERT SQL을 데이터베이스에 전달한다.**    
   
객체를 조회할 때 외래키를 변환하는 일도 JPA가 처리해준다.     
```java
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```

### JPA와 객체 그래프 탐색 
기존 객체 그래프 탐색은 SQL에 따라 탐색할 수 있는 객체의 범위가 제한되었었다. (JOIN 안하면 못가져옴)   
하지만 JPA를 이용하면 객체 그래프를 마음껏 탐색할 수 있다.   

```java
Member member = jpa.find(Member.class, memberId);   
member.getOrder().getOrderItem().getOrderOptionGroup().getOderOption()...
```
**JPA는 연관된 객체를 `사용하는 시점`에 적절한 SELECT SQL을 실행한다.**    
이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 **지연 로딩**이라고 한다.   
JPA는 지연로딩을 투명하게 처리하기에 추가적으로 JPA 와 관련된 어떤 코드도 직접 사용하지 않는다.    

```java
// 별다른 코드는 없다. 그저 우리는 사용만 하면된다.   
public Oreder getOrder(){
    return order; 
}
```

즉, 사용하는 시점에 조회를 실행한다고 보면된다.   
```java
// 처음 조회 시점에 SELECT MEMBER SQL
Member member = jpa.find(Member.class, memberId);

Order order = member.getOrder();
order.getOrderDate(); // Order를 사용하는 시점에 SELECT ORDER SQL    
```

물론 이같은 방법이 무조건적으로 좋다고 말 할 수는 없다.     
왜냐하면 데이터베이스와 연결을 2번 해야하기 때문이다.   
그렇기에 A라는 클래스와 연관된 B라는 클래스를 자주 사용한다면   
차라리 지연 로딩보다 **즉시 로딩**을 설정해주면 좋다.    

필자 개인적인 생각으로 엔티티의 `@ManyToMany`와 같은 `@연관관계어노테이션`에서    
LAZY 와 EAGER를 제공해주는데 이것이 위 내용인 것같다.     
어노테이션이 있는 해당 필드(객채) 사용에 있어 로딩 시기를 정하는 용도로 사용하기 때문이다.   
    
* `@연관관계어노테이션(fetch = FetchType.LAZY)` : 내부(해당) 클래스 사용할 때 DB에서 조회      
* `@연관관계어노테이션(fetch = FetchType.EAGER)` : 외부 클래스 조회할때 DB에서 같이 조회     
  
### JPA와 비교  
JPA는 **같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.**  

```
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

System.out.println(member1 == member2); // true 반환 
```
    
**여기서 같은 트랜잭션이란?**      
한개의 메서드 안에서 동작을 의미하는 것 같다.      
예를 들면 기존 Service 클래스에서 메서드 위에 `@Transactional`을 사용하는데   
해당 어노테이션은 **선언적 트랜잭션**을 지원해준다.   

**선언적 트랜잭션 :**  단일 트랜잭션의 범위, 롤백 규칙 등을 정의해준다.          
출처: https://crosstheline.tistory.com/96 [이거 알아영???ㅎㅎㅎ]

```jpa
    @Transactional
    public Long save(UserSaveRequsetDto requestDto){
        return userRepository.save(requestDto.toEntity()).getId();
    }
```

하지만 같은 트랜잭션일때 객체가 동등하다는 것을 보장해준다는 것이기에        
객체 비교는 분산 환경이나 트랜잭션이 다른 상황까지 고려하면 더 복잡해진다.       
이에 관해서는 나중에 설명하도록 하겠다.         
   
### 패러다임의 불일치 정리 
객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.   
문제는 이 패러다임의 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다는 점이다.   
그리고 더 어려운 문제는 **정교한 객체 모델링을 할 수록 불일치 문제를 해결하기 위한 노력이 더욱 필요하다**     
    
**JPA는 이러한 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델리을 유지하게끔 도와준다.**    
무조건 좋다는 말은 아니지만 개발자는 이로인해 더욱 개발에만 집중할 수 있게 되었다.    

___
## JPA란 무엇인가    
JPA는 **자바 ORM 기술 표준이다.**      
   
![jpa logic location](https://user-images.githubusercontent.com/50267433/94276100-c0945780-ff82-11ea-95e1-18200dc033a8.png)    
위 그림과 같이 JPA는 애플리케이션과 JDBC 사이에서 동작한다.       

그렇다면 ORM은 무엇일까?     
    
**ORM (Object Relation Mapping) :**   
* 객체와 관계형 데이터베이스를 매핑해주는 기술            
* 객체와 테이블을 매핑해서 패러다임 불일치 문제를 개발자 대신 해결해준다.                
       
즉, 객체를 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면    
ORM 프레임워크가 적절한 SQL을 생성해서 데이터 베이스에 쿼리를 전달해준다.         
또한 반대로 DB에서 넘어온 데이터를 객체 필드에 알맞게 주입시켜준다.          
    
ORM 프레임워크는 SQL 생성 및 패러다임 불일치를 해소해주기 때문에   
객체지향 언어는 **정교한 객체 모델링**을 할 수 있고 RDB는 **데이터 중심 모델링**할 수 있다.          
덕분에 개발자는 데이터 중심인 관계형 데이터베이스를 사용해도 객체지향 애플리케이션 개발에 집중할 수 있다.     

참고로 자바진영에서는 하이버네이트 프레임워크를 주로 사용한다.    
**하이버네이트 프레임워크는 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 프레임워크다.**      

### JPA 소개 
과거 `EJB` 안에도 `Entity Bean`이라는 ORM 기술이 있었지만 무겁고 기술 성숙도가 낮아 애플리케이션 서버에서만 사용했다.    
    
이후 `Hibernate`라는 오픈소스 ORM 프레임워크가 등장하였는데     
**가볍고 기술 성숙도가 높으며 서버 없이도 동작이 가능하여 많은 개발자가 사용하게 되었다.**    

결국 대부분의 개발자들의 Hibernate를 이용하기에 EJB에서도 Hibernate 기반 ORM 프레임워크를 만들게 되었고 이것이 JPA이다.   
  
[그림]   

JPA는 **자바 ORM 기술에 대한 API 표준 명세이다.**        
즉 다르게 말하면 여러 프레임워크에서 사용할 수 있도록 만든 **표준 인터페이스**이다.  
그렇기에 JPA를 사용한다는 것은 JPA를 구현한 ORM 프레임워크를 사용한다는 것이고 이 종류는 다양하다.    
JPA 2.1 기준으로는 Hibernate, EclipseLink, DataNucleus 가 있다.(현재 2.2까지 나온듯하다)    
그리고 Hibernate를 주로 사용한다.      
   
JPA라는 표준 덕분에 특정 구현 기술(Hibernate 같은 것들)에 대한 의존도를 줄일 수 있고     
다른 구현 기술로 손쉽게 이동할 수 있는 장점이 있다.     

### 왜 JPA를 사용해야 하는가   
* 생산성
    * 컬렉션 저장하듯이 JPA 에게 객체를 전달하면 된다. (쿼리 작성및 JDBC 반복구조 사용 안해도된다.)       
    * `jpa.persist(member); 또는 Member member = jpa.find(member_id);`     
    * DDL, DML 같은 쿼리문을 자동으로 생성해주기 때문에 개발자는 DB설계 중심 패러다임에서 객체 설계 중심으로 개발에 집중할 수 있다.
* 유지보수 
    * SQL을 직접 다루면 추가 요청사항 또는 수정시에 SQL 및 관련 코드들을 직접 수정하고 관리해야한다.   
    * JPA를 사용하면 이러한 작업을 프레임워크에 맞기게 되고 유지보수해야할 코드가 줄어들어 유지보수에 좋아진다.
* 패러다임 불일치 해결   
    * 앞선 내용처럼 데이터 중심이 아닌 객체중심 설계를 이용하여 객체를 더욱 객체스럽게 만들 수 있다.       
* 성능
    * JPA는 애플리케이션과 데이터베이스 사이에서 동작하므로 다양한 성능 최적화 기회를 제공해준다.   
    * JPA는 캐시 기능과 비슷한게 있어서 같은 데이터를 2번 조회할시 처음에는 SELECT를 사용하지만 2번째는 기존 객체를 리턴한다.   
* 데이터 접근 추상화와 벤더 독립성 
    * 여기서 말하는 벤더는 공급자로 RDBMS라 생각하면된다.   
    * 관계형 데이터베이스는 같은 기능도 벤더마다 사용법(방언, 기술)이 다르므로 변경이 있을시 이를 관리하기 어렵다.    
    * JPA는 추상화된 데이터 접근 계층을 제공해서 특정 데이터베이스 기술에 종속되지 않도록 한다.   
    * 즉, 데이터를 분석하여 알맞은 RDBMS에 맞게끔 쿼리를 생성해서 전달한다.     
* 표준 
    * 표준 인터페이스이므로 다양한 프레임워크를 사용하기 쉽도록 해준다.    

### 정리
SQL을 직접 다루면 생기는 문제점과 패러다임 불일치에 대해서 알게되었다.     
그리고 JPA가 무엇이고 JPA가 이들을 어떻게 해결하는지도 알아보았다.     
이점을 잊지말고 JPA를 더 잘 활용할 수 있도록 개발하도록 하며 또한 저자님처럼 문제점을 파악하는 생각을 기르도록 하자       
   
___
**[맨위로](#JPA-소개)**       
















 
 
 








